% Generic Simulink Documentation Generator
% This script generates a PDF documentation for any Simulink model
% It supports subsystems, referenced models, and Stateflow diagrams

% User Input: Set these variables before running the script
modelName = 'CAT_Main_model';  % Replace with your Simulink model name
version = '';  % Optional: Set the version number (e.g., '1.0') or leave empty
outputFolderPath = 'C:\Users\Lukas.Ernsund\OneDrive - Heart Aerospace\Desktop\Test documentation';  % Optional: Set the output folder path or leave empty for default

import slreportgen.report.*
import slreportgen.finder.*
import mlreportgen.report.*
import mlreportgen.dom.*

generateReport(modelName, version, outputFolderPath);

function generateReport(modelName, version, outputFolderPath)
    import slreportgen.report.*
    import slreportgen.finder.*
    import mlreportgen.report.*
    import mlreportgen.dom.*

    try
        % Validate inputs
        if isempty(modelName)
            error('Model name cannot be empty. Please set the modelName variable at the beginning of the script.');
        end
        
        % Load the model
        load_system(modelName);

        disp("Building report...");

        % Set up output directory
        if isempty(outputFolderPath)
            outputFolder = fullfile(pwd, 'Documentation');
        else
            outputFolder = outputFolderPath;
        end
        
        if ~exist(outputFolder, 'dir')
            mkdir(outputFolder);
        end
        
        outputFile = fullfile(outputFolder, modelName);

        % Initialize the report
        rpt = slreportgen.report.Report(outputFile, 'pdf');
        rpt.CompileModelBeforeReporting = false;

        % Create title page
        disp("Building title page...");
        tp = TitlePage;
        if ~isempty(version)
            tp.Title = ['Model Documentation: ' upper(version)];
        else
            tp.Title = 'Model Documentation';
        end
        tp.Subtitle = 'System Design Description';
        tp.Author = "Generated by Simulink Documentation Generator";
        try
            tp.Image = Diagram(modelName);
        catch E
            warning(E.identifier, 'Failed to create diagram for title page: %s', E.message);
        end
        append(rpt, tp);

        % Add table of contents
        disp("Building table of contents...");
        toc = TableOfContents;
        toc.NumberOfLevels = 9;
        append(rpt, toc);

        % Main chapter for the model hierarchy
        disp("Building model documentation...");
        ch = Chapter('Title', modelName);
        append(ch, newline);
        
        % Start the recursive model exploration
        exploreModel(modelName, ch, rpt);
        
        append(rpt, ch);

        % Add Stateflow documentation
        disp("Building Stateflow documentation...");
        chartFinder = ChartDiagramFinder(modelName);
        exploreChart(chartFinder, rpt);

        % Finalize and display the report
        close(rpt);
        rptview(rpt);

        % Clean up
        closeReferencedModels(modelName);
        disp(['Documentation generation complete! Output saved to: ' outputFolder]);
    catch ME
        fprintf('An error occurred: %s\n', ME.message);
        fprintf('Error details:\n');
        disp(getReport(ME));
    end
end

function exploreChart(chartFinder, rpt)
    import slreportgen.report.*
    import slreportgen.finder.*
    import mlreportgen.report.*
    import mlreportgen.dom.*

    while hasNext(chartFinder)
        chart = next(chartFinder);
        chapter = Chapter(Title=chart.Name);
        add(chapter, chart)
        
        % States section
        sect = Section(Title="States");
        stateFinder = StateFinder(chart.Object);
        states = find(stateFinder);
        for state = states
            add(sect, state);
            append(sect, newline);
            
            % Add constant table for each state
            stateLabel = state.Object.LabelString;
            constTable = createConstantTable(stateLabel);
            
            % Only add the table if it has more than just the header row
            if constTable.NRows > 1
                add(sect, constTable);
                append(sect, newline);
            end
        end  
        add(chapter, sect)
    
        % Transitions section
        sect = Section(Title="Transitions");
        transitionFinder = StateflowDiagramElementFinder...
           (Container=chart.Object,Types="transition");
        transitions = find(transitionFinder);
        for transition = transitions
            add(sect, transition)
            append(sect, newline);
            
            % Add constant table for each transition
            transitionLabel = transition.Object.LabelString;
            constTable = createConstantTable(transitionLabel);
            
            % Only add the table if it has more than just the header row
            if constTable.NRows > 1
                add(sect, constTable);
                append(sect, newline);
            end
        end  
        add(chapter, sect)
        add(rpt, chapter)
    end
end

function constTable = createConstantTable(label)
    import mlreportgen.dom.*
    
    constTable = Table(2);
    constTable.Style = {Border('solid'), ColSep('solid'), RowSep('solid'), Width('100%')};
    
    % Add header row
    headerRow = TableRow();
    headerStyle = {Bold(), BackgroundColor('lightgray'), HAlign('center')};
    cols = {'Constant', 'Value'};
    for i = 1:2
        entry = TableEntry(cols{i});
        entry.Style = headerStyle;
        append(headerRow, entry);
    end
    append(constTable, headerRow);
    
    % Split label into words and check for constants
    words = splitLabel(label);
    for i = 1:length(words)
        word = words{i};
        % Check if the word is not just a number
        if ~isStringNumber(word)
            try
                value = evalin('base', word);
                if ~isempty(value)
                    row = TableRow();
                    append(row, TableEntry(word));
                    append(row, TableEntry(num2str(value)));
                    append(constTable, row);
                end
            catch
                % Word not found in base workspace, move to next word
            end
        end
    end
end

function words = splitLabel(label)
    % Split the label into words based on multiple delimiters
    words = strsplit(label, {' ', newline, ';', '=', '<', '>'});
    % Remove any empty strings
    words = words(~cellfun('isempty', words));
end

function exploreModel(modelName, parentChapter, rpt)
    import slreportgen.report.*
    import slreportgen.finder.*
    import mlreportgen.report.*
    import mlreportgen.dom.*

    % Create a section for the current model
    section = Section('Title', modelName);
    append(section, newline);
    
    % Add model description
    modelDescription = get_param(modelName, 'Description');
    if ~isempty(modelDescription)
        append(section, Paragraph(modelDescription));
        append(section, newline); % Add a line break after the description
    end
    
    % Add model diagram
    try
        append(section, Diagram(modelName));
        append(section, newline); % Add a line break after the diagram
    catch ME
        warning('Failed to create diagram for model %s: %s', modelName, ME.message);
        append(section, Paragraph(['Unable to create diagram for model ' modelName]));
        append(section, newline); % Add a line break after the error message
    end
    
    % Find blocks in the current model
    blkFinder = BlockFinder(modelName);
    blocks = find(blkFinder);
    
    % Create and populate tables for the model
    [inputTable, outputTable, constTable] = createTables(blocks);
    
    % Add tables to section if they exist
    if inputTable.NRows > 1
        append(section, inputTable);
        append(section, newline); % Add a line break after the table
    end
    if outputTable.NRows > 1
        append(section, outputTable);
        append(section, newline); % Add a line break after the table
    end
    if constTable.NRows > 1
        append(section, constTable);
        append(section, newline); % Add a line break after the table
    end
    
    append(parentChapter, section);

    % Subsystems section
    subsystemsSection = Section('Title', 'Subsystems');
    shouldAppend = exploreSubsystems(modelName, subsystemsSection);
    if shouldAppend
        append(parentChapter, subsystemsSection);
    end

    % Referenced Models section
    referencedModelsSection = Section('Title', 'Referenced Models');
    shouldAppend = exploreReferencedModels(modelName, referencedModelsSection, rpt);
    if shouldAppend
        append(parentChapter, referencedModelsSection);
    end
end

function hasSubsystem = exploreSubsystems(modelName, parentSection)
    import slreportgen.report.*
    import slreportgen.finder.*
    import mlreportgen.report.*
    import mlreportgen.dom.*

    hasSubsystem = false;

    % Find all subsystems in the model
    subsystems = find_system(modelName, 'FindAll', 'on', 'Type', 'Block', 'BlockType', 'SubSystem');

    for i = 1:length(subsystems)
        try
            subsystemPath = getfullname(subsystems(i));
            subsystemName = get_param(subsystems(i), 'Name');
            
            % Skip if this subsystem is the same as the parent (to avoid repetition)
            if strcmp(subsystemPath, modelName)
                continue;
            end
            
            if contains(get_param(subsystemPath,"Name"), "Compare"+newline+"To Constant") ...
                || contains(get_param(subsystemPath,"Name"), "PID Controller")
                continue
            end

            section1 = Section("Title", subsystemName);

            hasSubsystem = true;
            
            % Add subsystem description
            subsystemDescription = get_param(subsystemPath, 'Description');
            if ~isempty(subsystemDescription)
                append(section1, Paragraph(subsystemDescription));
                append(section1, newline); % Add a line break after the description
            end
            
            % Try to add the subsystem diagram
            try
                append(section1, Diagram(subsystemPath));
                append(section1, newline); % Add a line break after the diagram
            catch ME
                warning('Failed to add diagram for subsystem %s: %s', subsystemName, ME.message);
                append(section1, Paragraph(['Unable to create diagram for subsystem ' subsystemName]));
                append(section1, newline); % Add a line break after the error message
            end
            
            % Add blocks within the subsystem
            blkFinder1 = BlockFinder(subsystemPath);
            elems = find(blkFinder1);
            
            % Create and populate tables for the subsystem
            [inputTable, outputTable, constTable] = createTables(elems);
            
            % Add tables to section
            if inputTable.NRows > 1
                append(section1, inputTable);
                append(section1, newline); % Add a line break after the table
            end
            if outputTable.NRows > 1
                append(section1, outputTable);
                append(section1, newline); % Add a line break after the table
            end
            if constTable.NRows > 1
                append(section1, constTable);
                append(section1, newline); % Add a line break after the table
            end
            append(parentSection, section1);
            
            % Check if this subsystem has nested subsystems
            nestedSubsystems = find_system(subsystemPath, 'SearchDepth', 1, 'BlockType', 'SubSystem');
            nestedSubsystems = nestedSubsystems(2:end); % Remove the subsystem itself from the list
            
            if ~isempty(nestedSubsystems)
                % Create a nested Subsystems section
                nestedSubsystemsSection = Section('Title', 'Subsystems');
                exploreSubsystems(subsystemPath, nestedSubsystemsSection);
                append(section1, nestedSubsystemsSection);
            end
        catch ME
            warning('Error processing subsystem %s: %s', subsystemName, ME.message);
            % Continue to the next subsystem
        end
    end
end

function hasReferencesModels = exploreReferencedModels(modelName, parentSection, rpt)
    import slreportgen.report.*
    import slreportgen.finder.*
    import mlreportgen.report.*
    import mlreportgen.dom.*

    hasReferencesModels = false;

    % Find referenced models within this model
    [referencedModels, ~] = find_mdlrefs(modelName, 'KeepModelsLoaded', true, 'IncludeCommented', false, 'FollowLinks', true, 'MatchFilter',@Simulink.match.activeVariants);
    
    % Sort referenced models alphabetically
    referencedModels = sort(referencedModels);
    
    % Explore each referenced model
    for i = 1:length(referencedModels)
        if ~strcmp(referencedModels{i}, modelName)  % Avoid infinite recursion
            try
                refModelSection = Section('Title', referencedModels{i});
                exploreModel(referencedModels{i}, refModelSection, rpt);
                append(parentSection, refModelSection);
                hasReferencesModels = true;
            catch ME
                warning('Error processing referenced model %s: %s', referencedModels{i}, ME.message);
                % Continue to the next referenced model
            end
        end
    end
end

function closeReferencedModels(topModel)
    [referencedModels, ~] = find_mdlrefs(topModel, 'KeepModelsLoaded', true, 'IncludeCommented', false, 'FollowLinks', true, 'MatchFilter',@Simulink.match.activeVariants);
    for i = 1:length(referencedModels)
        if ~strcmp(referencedModels{i}, topModel)
            close_system(referencedModels{i}, 0);
        end
    end
end

% createTables.m
function [inputTable, outputTable, constTable] = createTables(blocks)
    import slreportgen.report.*
    import slreportgen.finder.*
    import mlreportgen.report.*
    import mlreportgen.dom.*
    
    % Create input table
    inputTable = Table(4);
    inputTable.Style = {Border('solid'), ColSep('solid'), RowSep('solid'), Width('100%')};

    % Create output table
    outputTable = Table(4);
    outputTable.Style = {Border('solid'), ColSep('solid'), RowSep('solid'), Width('100%')};

    % Create constant table
    constTable = Table(2);
    constTable.Style = {Border('solid'), ColSep('solid'), RowSep('solid'), Width('100%')};

    % Style for header row
    headerStyle = {Bold(), BackgroundColor('lightgray'), HAlign('center')};

    % Add header rows with styling
    headerRow = TableRow();
    cols = {'Input Signal', 'Data Type', 'Description', 'Unit'};
    for i = 1:4
        entry = TableEntry(cols{i});
        entry.Style = headerStyle;
        append(headerRow, entry);
    end
    append(inputTable, headerRow);

    headerRow = TableRow();
    cols = {'Output Signal', 'Data Type', 'Description', 'Unit'};
    for i = 1:4
        entry = TableEntry(cols{i});
        entry.Style = headerStyle;
        append(headerRow, entry);
    end
    append(outputTable, headerRow);

    headerRow = TableRow();
    cols = {'Constant', 'Value'};
    for i = 1:2
        entry = TableEntry(cols{i});
        entry.Style = headerStyle;
        append(headerRow, entry);
    end
    append(constTable, headerRow);

    % Populate tables
    for block = blocks
        if block.Type == "Inport"
            name = block.Name;
            dataType = get_param(block.BlockPath,'OutDataTypeStr');
            description = get_param(block.BlockPath,'Description');
            unit = get_param(block.BlockPath,'Unit');
            row = TableRow();
            append(row, TableEntry(name));
            append(row, TableEntry(dataType));
            append(row, TableEntry(description));
            append(row, TableEntry(unit));
            append(inputTable, row);
        elseif block.Type == "Outport"
            name = block.Name;
            dataType = get_param(block.BlockPath,'OutDataTypeStr');
            description = get_param(block.BlockPath,'Description');
            unit = get_param(block.BlockPath,'Unit');
            row = TableRow();
            append(row, TableEntry(name));
            append(row, TableEntry(dataType));
            append(row, TableEntry(description));
            append(row, TableEntry(unit));
            append(outputTable, row);
        elseif block.Type == "Constant" || block.Type == "Gain"
            if block.Type == "Constant"
                propertyName = 'Value';
            else
                propertyName = 'Gain';
            end
            name = get_param(block.BlockPath, propertyName);
            % Check if the name is not just a number and not 'const'
            if ~isStringNumber(name) && ~strcmp(name, 'const')
                try
                    value = evalin('base', name);
                    row = TableRow();
                    append(row, TableEntry(name));
                    
                    if isnumeric(value) && ~isscalar(value)
                        % For numeric arrays, convert each element to string, join with commas, and wrap in brackets
                        valueStr = "[" + strjoin(string(value), ', ') + "]";
                    else
                        % For everything else, including scalars, use string conversion
                        valueStr = string(value);
                    end
                    
                    append(row, TableEntry(valueStr));
                    append(constTable, row);
                catch
                    % Variable not found in base workspace, skip it
                end
            end
        end
    end
end

function result = isStringNumber(str)
    % Check if the string represents a number (including floating point and scientific notation)
    % or if it's a boolean literal ('false' or 'true')
    result = ~isempty(str) && ...
             (all(isstrprop(str, 'digit')) || ...
              ~isnan(str2double(str)) || ...
              strcmpi(str, 'false') || ...
              strcmpi(str, 'true'));
end